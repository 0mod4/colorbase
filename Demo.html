<!doctype html>
<html lang="de">
<head>
	<link rel="stylesheet" href="css/normalize.css" media="screen" charset="utf-8">
	<link rel="stylesheet" href="css/style.css" media="screen" charset="utf-8">
	<script src='js/sql.js'></script>
	<script src='js/jquery.min.js'></script>
	<script src='js/caret.js'></script>
	<script type="text/javascript" src="js/glMatrix-0.9.5.min.js"></script>

	<script id="shader-vs" type="x-shader/x-vertex" >
		attribute vec3 aVertexPosition;

	    uniform mat4 uMVMatrix;
	    uniform mat4 uPMatrix;

	    void main(void) {
	        gl_Position = vec4(aVertexPosition, 1.0);//uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	    }
	</script>
	<script id="shader-fs" type="x-shader/x-fragment">
	    precision mediump float;

		float sdSphere( vec3 p, float s )
		{
		    return length(p)-s;
		}

		float udRoundBox( vec3 p, vec3 b, float r )
		{
		  	return length(max(abs(p)-b,0.0))-r;
		}

		float sdBox( vec3 p, vec3 b )
		{
		  	vec3 d = abs(p) - b;
		  	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
		}

		float opRep( vec3 p, vec3 c, vec3 b, float r )
		{
		    vec3 q = mod(p,c)-0.5*c;
		    //return udRoundBox( q, b, r );
		    return sdBox(q,b);
		}

		//----------------------------------------------------------------------

		vec2 opU( vec2 d1, vec2 d2 )
		{
			return (d1.x<d2.x) ? d1 : d2;
		}

		//----------------------------------------------------------------------
		const int Nx = 20;
		const int Ny = 20;
		const int Nz = 20;

		float precis = 0.002;

		float round(float v)
		{
			return floor(v+0.5);
		}
//return obj_union(obj_floor(p), op_rep(p, vec3(8.0, 8.0, 8.0)));
		vec2 map( in vec3 pos )
		{
			float r = 0.2; //radius of smooth edges
			float c = 1.5; //distance between blocks
			float offsetx = -7.;//-4.5;
			float offsety = 7.;//4.5;
			float offsetz = 14.;//-9.;
			vec3 offset = vec3(offsetx, offsety, offsetz);
			float stepsizex = abs(offsetx)*2. / float(Nx);
			float stepsizey = abs(offsety)*2. / float(Ny);
			float stepsizez = abs(offsetz)/ float(Nz);
			//Wööööfl
			vec2 res = vec2(5.0);
			float bound = 5.;
			if((round(abs(pos.x)) < bound) && (round(abs(pos.y))<bound) && (round(abs(pos.z))<bound))
				res = opU( res, vec2 ( opRep(pos-offset, vec3(1)*c, vec3(1)*r, 0.1), 0.0 ));//udRoundBox(pos-offset, vec3(1, 1, 1)*r, 0.1 ), 0.0));
		        
		    return res;
		}

		vec2 castRay( in vec3 ro, in vec3 rd )
		{
		    float tmin = 1.0;
		    float tmax = 20.0;
		    
		#if 0
		    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
		    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
		                                                 else           tmax = min( tmax, tp2 ); }
		#endif
		    
			float precis = 0.002;
		    float t = tmin;
		    float m = -1.0;
		    for( int i=0; i<50; i++ )
		    {
			    vec2 res = map( ro+rd*t );
		        if( res.x<precis || t>tmax ) break;
		        t += res.x;
			    m = res.y;
		    }

		    if( t>tmax ) m=-1.0;
		    return vec2( t, m );
		}


		float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
		{
			float res = 1.0;
		    float t = mint;
		    for( int i=0; i<16; i++ )
		    {
				float h = map( ro + rd*t ).x;
		        res = min( res, 8.0*h/t );
		        t += clamp( h, 0.02, 0.10 );
		        if( h<0.001 || t>tmax ) break;
		    }
		    return clamp( res, 0.0, 1.0 );

		}

		vec3 calcNormal( in vec3 pos )
		{
			vec3 eps = vec3( 0.001, 0.0, 0.0 );
			vec3 nor = vec3(
			    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
			    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
			    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
			return normalize(nor);
		}

		float calcAO( in vec3 pos, in vec3 nor )
		{
			float occ = 0.0;
		    float sca = 1.0;
		    for( int i=0; i<5; i++ )
		    {
		        float hr = 0.01 + 0.12*float(i)/4.0;
		        vec3 aopos =  nor * hr + pos;
		        float dd = map( aopos ).x;
		        occ += -(dd-hr)*sca;
		        sca *= 0.95;
		    }
		    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
		}

		vec4 render( in vec3 ro, in vec3 rd )
		{ 
		    vec4 col = vec4(0, 0, 0, 0);
		    vec2 res = castRay(ro,rd);
		    float t = res.x;
			float m = res.y;
		    if( m>-0.5 )
		    {
		        vec3 pos = ro + t*rd;
		        vec3 nor = calcNormal( pos );
		        vec3 ref = reflect( rd, nor );
		        
		        // material        
		        if( m<0.1 )
		        {
		            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);
		            col.rgb = vec3(0,0,1);//color of the box
		            col.a = 1.;

			        // lighitng        
			        float occ = calcAO( pos, nor );
					vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );
					float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
			        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
			        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
			        float dom = smoothstep( -0.1, 0.1, ref.y );
			        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
					float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);
			        
			        dif *= softshadow( pos, lig, 0.02, 2.5 );
			        dom *= softshadow( pos, ref, 0.02, 2.5 );

					vec3 lin = vec3(0.0);
			        lin += 1.20*dif*vec3(1.00,0.85,0.55);
					lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;
			        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;
			        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;
			        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;
			        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;
					col.rgb = col.rgb*lin;
		        }
		    }

			return vec4(clamp(col,0.0,1.0));
		}

		mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
		{
			vec3 cw = normalize(ta-ro);
			vec3 cp = vec3(sin(cr), cos(cr),0.0);
			vec3 cu = normalize( cross(cw,cp) );
			vec3 cv = normalize( cross(cu,cw) );
		    return mat3( cu, cv, cw );
		}

		void main()
		{
			vec2 q = gl_FragCoord.xy/vec2(500,500);
		    vec2 p = -1.0+2.0*q;
			p.x *= 1.0; //res.x/res.y

			// camera	
			vec3 translation = vec3( 0, 0, 0);
			vec3 rotation = vec3(0,0,10); //3 as start z //make dependent on mouse
			
			// get view matrix
		    mat3 ca = setCamera( rotation, translation, 0.0 );
		    
		    // ray direction
			vec3 rd = ca * normalize( vec3(p.xy,2.0) );

		    // render	
		    vec4 col = render( rotation, rd );

			col = pow( col, vec4(0.4545) );

		    gl_FragColor = col;//vec4( col, 1.0 );
		    //gl_FragColor = vec4( q, 0, 1);
		}
	</script>
	<script src='js/Demo.js'></script>
	<script src='js/Demo3D.js'></script>
	<script src='js/globals.js'></script>
	<script src='js/starfield.js'></script>
	<script src='js/gui.js'></script>
</head>

<script>
	$().ready(function() {
		$().initGUI();
	})

var numStars = 50;
var rows = 50;
var cols = 50;
var peter = 100;

	function toggleStarfield() {
		//start stars
 		if ($("#starfield_toggle").prop( "checked" )) {
 			$().createStarfield(numStars)
 		} else {
 			$().removeStarfield()
 		}
 	}

	function init() 
	{
		if($('input[name="Dimension"]:checked').val() == 3)
		{
			ThreeD.init()
		}
		else
		{
			TwoD.init()
		}
	}

	function toggleDimension()
	{
		if($('input[name="Dimension"]:checked').val() == "3")
		{
			ThreeD.cleanup()
			ThreeD.init()
		}
		else
		{
			TwoD.cleanup()
			TwoD.init()
		}
	}

	function execute()
	{
		if($('input[name="Dimension"]:checked').val() == "3")
			ThreeD.execute();
		else
			TwoD.execute();
	}
</script>

<body onload="init()">

	<div class="inputform">
		<form action="#" onsubmit="execute()" name="form" autocomplete="off">
			<input name="queryText" type="text" id="queryText" size="120" value="select * from dummy" autocomplete="off"><div class="marker"></div>
		</form>
 	</div>

 	<div class="optionform">
		<a href="#" class="toggle">Toggle Settings</a>
 		<form name="options">
			<fieldset>
				<input type="radio" id="in" name="Transition" value="in">
				<label for="in">Instant</label>
				<input type="radio" id="del" name="Transition" value="del">
				<label for="del">Delay</label>
			</fieldset>
			<fieldset>
				<label for="playMusic">Music</label>
				<input type="checkbox" id="playMusic" onClick="toggleMusic()" value="Play">
				<input type="text" id="numSoundBars" size="40" value="5">
				<label for="useVideo">Video</label>
				<input type="checkbox" id="useVideo" onClick="toggleVideo()" value="Play">
				<input type="radio" id="2D" name="Dimension" value="2">
				<label for="2D">2D</label>
				<input type="radio" id="3D" name="Dimension" value="3" checked = "checked">
				<label for="3D">3D</label>
				<label for="starfield_toggle">OMG it's full of stars!</label>
				<input type="checkbox" id="starfield_toggle" onClick="toggleStarfield()" value="On">
			</fieldset>
		</form>
 	</div>

  <div id="videoDiv">
    	<video id="camFeed" width="320" height="240" autoplay></video>
    	<canvas id="videoCanvas" width="50" height="50"></canvas>
	</div>

	<div id="container">
		<!-- This is filled with cells later -->
	</div>

</body>
