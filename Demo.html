<!doctype html>
<html lang="de">
<head>
	<script src='js/sql.js'></script>
	<script src="js/jquery.min.js"></script>
	<script type="text/javascript" src="js/glMatrix-0.9.5.min.js"></script>
	<link rel="stylesheet" href="css/normalize.css" media="screen" charset="utf-8">
	<link rel="stylesheet" href="css/style.css" media="screen" charset="utf-8">

	<script id="shader-vs" type="x-shader/x-vertex" >
		attribute vec3 aVertexPosition;

	    uniform mat4 uMVMatrix;
	    uniform mat4 uPMatrix;

	    void main(void) {
	        gl_Position = vec4(aVertexPosition, 1.0);//uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	    }
	</script>
	<script id="shader-fs" type="x-shader/x-fragment">
	    precision mediump float;

		float sdSphere( vec3 p, float s )
		{
		    return length(p)-s;
		}

		float sdBox( vec3 p, vec3 b )
		{
		  	vec3 d = abs(p) - b;
		  	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
		}

		float udRoundBox( vec3 p, vec3 b, float r )
		{
		  return length(max(abs(p)-b,0.0))-r;
		}

		//----------------------------------------------------------------------

		vec2 opU( vec2 d1, vec2 d2 )
		{
			return (d1.x<d2.x) ? d1 : d2;
		}

		vec3 opRep( vec3 p, vec3 c )
		{
		    return mod(p,c)-0.5*c;
		}

		//----------------------------------------------------------------------
		const int Nx = 5;
		const int Ny = 5;
		const int Nz = 5;

		vec2 map( in vec3 pos )
		{
			float r = 0.1;
			float offsetx = -4.5;
			float offsety = 4.5;
			float offsetz = 0.;
			vec3 offset = vec3(offsetx, offsety, offsetz);
			float stepsizex = abs(offsetx)*2. / float(Nx);
			float stepsizey = abs(offsety)*2. / float(Ny);
			float stepsizez = abs(offsetz)*2. / float(Nz);
			//Wööööfl
			vec2 res = vec2(1.0);
			for(int peter=0; peter<Nz; peter++)
			{
				for(int row=0; row<Ny; row++)
				{
					for(int col=0; col<Nx; col++)		
					{
						res = opU( res, vec2( udRoundBox(pos-offset, vec3(1, 1, 1)*r, 0.1 ), 0.0));
						offset.x = offset.x + stepsizex;
					}		
					offset.y = offset.y + stepsizey;
					offset.x = offsetx;
				}
				offset.z = offset.z + stepsizez;
				offset.x = offsetx;
				offset.y = offsety;
			}
//offset = vec3(-4.5, 4.5, 0.5);

		    
		    //res = opU (res, )
		        
		    return res;
		}

		vec2 castRay( in vec3 ro, in vec3 rd )
		{
		    float tmin = 1.0;
		    float tmax = 20.0;
		    
		#if 0
		    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
		    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
		                                                 else           tmax = min( tmax, tp2 ); }
		#endif
		    
			float precis = 0.002;
		    float t = tmin;
		    float m = -1.0;
		    for( int i=0; i<50; i++ )
		    {
			    vec2 res = map( ro+rd*t );
		        if( res.x<precis || t>tmax ) break;
		        t += res.x;
			    m = res.y;
		    }

		    if( t>tmax ) m=-1.0;
		    return vec2( t, m );
		}


		float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
		{
			float res = 1.0;
		    float t = mint;
		    for( int i=0; i<16; i++ )
		    {
				float h = map( ro + rd*t ).x;
		        res = min( res, 8.0*h/t );
		        t += clamp( h, 0.02, 0.10 );
		        if( h<0.001 || t>tmax ) break;
		    }
		    return clamp( res, 0.0, 1.0 );

		}

		vec3 calcNormal( in vec3 pos )
		{
			vec3 eps = vec3( 0.001, 0.0, 0.0 );
			vec3 nor = vec3(
			    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
			    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
			    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
			return normalize(nor);
		}

		float calcAO( in vec3 pos, in vec3 nor )
		{
			float occ = 0.0;
		    float sca = 1.0;
		    for( int i=0; i<5; i++ )
		    {
		        float hr = 0.01 + 0.12*float(i)/4.0;
		        vec3 aopos =  nor * hr + pos;
		        float dd = map( aopos ).x;
		        occ += -(dd-hr)*sca;
		        sca *= 0.95;
		    }
		    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
		}

		vec4 render( in vec3 ro, in vec3 rd )
		{ 
		    vec4 col = vec4(0, 0, 0, 0);
		    vec2 res = castRay(ro,rd);
		    float t = res.x;
			float m = res.y;
		    if( m>-0.5 )
		    {
		        vec3 pos = ro + t*rd;
		        vec3 nor = calcNormal( pos );
		        vec3 ref = reflect( rd, nor );
		        
		        // material        
		        if( m<0.1 )
		        {
		            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);
		            col.rgb = vec3(0,0,1);//color of the box
		            col.a = 1.;

			        // lighitng        
			        float occ = calcAO( pos, nor );
					vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );
					float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
			        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
			        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
			        float dom = smoothstep( -0.1, 0.1, ref.y );
			        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
					float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);
			        
			        dif *= softshadow( pos, lig, 0.02, 2.5 );
			        dom *= softshadow( pos, ref, 0.02, 2.5 );

					vec3 lin = vec3(0.0);
			        lin += 1.20*dif*vec3(1.00,0.85,0.55);
					lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;
			        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;
			        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;
			        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;
			        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;
					col.rgb = col.rgb*lin;
		        }
		    }

			return vec4(clamp(col,0.0,1.0));
		}

		mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
		{
			vec3 cw = normalize(ta-ro);
			vec3 cp = vec3(sin(cr), cos(cr),0.0);
			vec3 cu = normalize( cross(cw,cp) );
			vec3 cv = normalize( cross(cu,cw) );
		    return mat3( cu, cv, cw );
		}

		void main()
		{
			vec2 q = gl_FragCoord.xy/vec2(500,500);
		    vec2 p = -1.0+2.0*q;
			p.x *= 1.0; //res.x/res.y

			// camera	
			vec3 translation = vec3( 0, 0, 0);
			vec3 rotation = vec3(0,0,10); //3 as start z //make dependent on mouse
			
			// get view matrix
		    mat3 ca = setCamera( rotation, translation, 0.0 );
		    
		    // ray direction
			vec3 rd = ca * normalize( vec3(p.xy,2.0) );

		    // render	
		    vec4 col = render( rotation, rd );

			col = pow( col, vec4(0.4545) );

		    gl_FragColor = col;//vec4( col, 1.0 );
		    //gl_FragColor = vec4( q, 0, 1);
		}
	</script>
</head>

<script src='js/Demo.js'></script>
<script src='js/Demo3D.js'></script>
<script src='js/globals.js'></script>
<script src='js/starfield.js'></script>

<script>
var numStars = 50;
var rows = 50;
var cols = 50;
var peter = 100;

	function toggleStarfield() {
		//start stars
 		if ($("#starfield_toggle").prop( "checked" )) {
 			$().createStarfield(numStars)
 		} else {
 			$().removeStarfield()
 		}
 	}

	function init() 
	{
		if($('input[name="Dimension"]:checked').val() == 3)
		{
			ThreeD.init()
		}
		else
		{
			TwoD.init()
		}
	}

	function toggleDimension()
	{
		if($('input[name="Dimension"]:checked').val() == "3")
		{
			ThreeD.cleanup()
			ThreeD.init()
		}
		else
		{
			TwoD.cleanup()
			TwoD.init()
		}
	}

	function execute()
	{
		if($('input[name="Dimension"]:checked').val() == "3")
			ThreeD.execute();
		else
			TwoD.execute();
	}
</script>

<body onload="init()">

	<div class="inputform">
			<form action="#" onsubmit="execute()" name="form">
				<input name="queryText" type="text" id="queryText" size="120" value="select * from dummy">
				<!-- <input name="queryButton" type="button" id="queryButton" onClick="execute()" value="my query"> -->
			</form>
			<form name="options">
				<fieldset>
					<input type="radio" id="in" name="Transition" value="in">
					<label for="in">Instant</label>
					<input type="radio" id="del" name="Transition" value="del">
					<label for="del">Delay</label>
				</fieldset>
				<fieldset>
					<label for="playMusic">Music</label>
					<input type="checkbox" id="playMusic" onClick="toggleMusic()" value="Play">
					<input type="text" id="numSoundBars" size="40" value="5">
					<label for="useVideo">Video</label>
					<input type="checkbox" id="useVideo" onClick="toggleVideo()" value="Play">
					<input type="radio" id="2D" name="Dimension" value="2" onChange="toggleDimension()">
					<label for="2D">2D</label>
					<input type="radio" id="3D" name="Dimension" value="3" checked="checked" onChange="toggleDimension()">
					<label for="3D">3D</label>
					<label for="starfield_toggle">OMG it's full of stars!</label>
					<input type="checkbox" id="starfield_toggle" onClick="toggleStarfield()" value="On">
				</fieldset>
			</form>
 	</div>

  <div id="videoDiv">
    	<video id="camFeed" width="320" height="240" autoplay></video>
    	<canvas id="videoCanvas" width="50" height="50"></canvas>
	</div>

	<div id="container">
		<!-- This is filled with cells later -->
	</div>

</body>
